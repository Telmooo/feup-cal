%----------------------------------------------------------------------------------------
%	PACKAGES AND DOCUMENT CONFIGURATIONS
%----------------------------------------------------------------------------------------
\documentclass[article, a4paper, 12pt, oneside]{memoir}

% Margins
\usepackage[top=3cm,left=2cm,right=2cm,bottom=3cm]{geometry}

% Encondings
\usepackage[utf8]{inputenc}

% Language
\usepackage[portuguese]{babel}

% Graphics and images
\usepackage{graphicx}
	\graphicspath{{../images/}}

% Tables
\usepackage{tabularx}

% Paragraph Spacing
\usepackage{parskip}
\usepackage{indentfirst}
\setlength{\parskip}{0.5cm}

% Hyperreferences
\usepackage{hyperref}

% Repeated commands
\usepackage{expl3}
\ExplSyntaxOn
\cs_new_eq:NN \Repeat \prg_replicate:nn
\ExplSyntaxOff

% Header and Footer Things
\usepackage{wallpaper}
\usepackage{fancyhdr}

% Following code to edit the pagestyle
\pagestyle{fancy}
\fancyhf{}
\rhead{Meat Wagons}
\lhead{\leftmark}
\rfoot{Página \thepage}

% Commands
\usepackage{xargs}

%% Linked Email
\newcommand{\email}[1]{
{\texttt{\href{mailto:#1}{#1}} }
}

%----------------------------------------------------------------------------------------
%	DOCUMENT INFORMATION
%----------------------------------------------------------------------------------------
% Title
\title{\Huge \texttt{Meat Wagons - Transporte de Prisioneiros} }
% Authors
\author{
\LARGE \textbf{Turma 2 Grupo 3}\\\\
\begin{tabular}{l r}
	\email{up201806250@fe.up.pt} & Diogo Samuel Gonçalves Fernandes	\\
	\email{up201806490@fe.up.pt} & Hugo Miguel Monteiro Guimarães \\
	\email{up201806554@fe.up.pt} & Telmo Alexandre Espirito Santo Baptista	\\
\end{tabular}
}

%\institute{Faculdade de Engenharia da Universidade do Porto \\ Bases de Dados (BDAD) - Turma 4, grupo 6}

% Date for the report
\date{\today}

% Table of Contents
\addto\captionsportuguese{\renewcommand*\contentsname{Índice}}

%----------------------------------------------------------------------------------------
%	DOCUMENT
%----------------------------------------------------------------------------------------
\begin{document}
%----------------------------------------------------------------------------------------
%	Front Page
%----------------------------------------------------------------------------------------
% Title Author and Date
\maketitle

% More information for front page
\begin{center}
\textbf{Projeto CAL - 2019/20 - MIEIC}
\Repeat{2}{\linebreak}
\begin{tabular}{l r}
	\textbf{Professor das Aulas Práticas}: & \href{https://sigarra.up.pt/feup/pt/func_geral.formview?p_codigo=419241}{Rosaldo José Fernandes Rossetti}
\end{tabular}
\Repeat{4}{\linebreak}
% FEUP Logo
\includegraphics[scale=0.4]{FEUP-logo.jpg}

\end{center}

\newpage
% Header Image
\CenterWallPaper{0.1}{FEUP-logo.jpg}
\addtolength{\wpXoffset}{-7.5cm}
\addtolength{\wpYoffset}{13.8cm}

%----------------------------------------------------------------------------------------
%	TABLE OF CONTENTS
%----------------------------------------------------------------------------------------
\tableofcontents*

\newpage
%----------------------------------------------------------------------------------------
%	CHAPTER 1 - Descrição do Problema
%----------------------------------------------------------------------------------------
\chapter[Descrição do Problema][Descrição do Problema]{Descrição do Problema} \label{\thechapter}

Os transportes de prisioneiros entre diversos estabelecimentos como, por exemplo, as prisões, esquadras e tribunais são feitos usando carrinhas que se encontram adaptadas ao serviço. Estes veículos têm a necessidade de serem altamente resistentes uma vez que é necessário garantir que os prisioneiros não conseguem escapar.

Para este projeto, queremos optimizar o percurso dos veículos de forma a recolher e entregar os prisioneiros nos pontos de interesse. De modo a cumprir o pretendido, é possivel dividir nas seguintes fases:


\subsection{Primeira Iteração - Recolha não seletiva de prisioneiros utilizando uma única carrinha}
	Inicialmente considere que só existe uma única camioneta para realizar todos os serviços.
	Com a primeira iteração pretende-se que apenas uma carrinha vá recolher os prisioneiros a uma dada localização, tendo em conta a urgência da situação. As situações que  sejam mais exigentes serão respondidas primeiro pela carrinha.

	É importante de notar que a recolha só pode ser efetuada se exisrem caminhos que liguem todos os pontos de interesse, ou seja, o grafo necessita de ser conexo.

	Algumas vezes, obras nas vias públicas podem fazer com que certas zonas tornem-se inacessíveis, inviabilizando o acesso ao destino de alguns prisioneiros. Avalie a conectividade do grafo, a fim de identificar pontos de recolha e de entrega com pouca acessibilidade.

\subsection{Segunda Iteração - Recolha seletiva de prisioneiros utilizando uma única carrinha}
	Durante a segunda fase, cada prisioneiro irá ser agrupado com outros prisioneiros sempre que seja possivel, de modo a não exceder a capacidade da carrinha.



\subsection{Terceira Iteração - Recolha seletiva de prisioneiros utilizando várias carrinhas}

	Concluindo, nesta ultima fase vai-se ter em consideração o diverso número de carrinhas que a frota possui. Algumas carrinhas vão diferir de outras, tendo cada carrinha uma determinada função. Por exemplo, vão existir carrinhas especificas para transportar prisioneiros até aos aeroportos, linhas de comboio.


\newpage

%----------------------------------------------------------------------------------------
%	CHAPTER 2 - Formalização do Problema
%----------------------------------------------------------------------------------------
\chapter[Formalização do Problema][Formalização do Problema]{Formalização do Problema} \label{\thechapter}

\section{Dados de Entrada}

$C_i$ - sequência de veículos, sendo $C_i(i)$ o seu i-ésimo elemento. Cada veículo é caraterizado por:
\begin{itemize}
	\item $capacity$ - número de prisioneiros que pode transportar
	\item $type$ - tipo de veículo
\end{itemize}

$R_i$ - sequência de pedidos de transporte de prisioneiros, sendo $R_i(i)$ o seu i-ésimo elemento. Cada pedido é caraterizado por:
\begin{itemize}
	\item $pickup$ - local de recolha dos prisioneiros
	\item $dest$ - local de destino dos prisioneiros
	\item $numPris$ - número de prisioneiros a serem transportados
	\item $type$ - tipo de prisioneiros
	\item $p_d$ - peso da distância no trajeto a efetuar
	\item $p_t$ - peso do tempo no trajeto a efetuar
\end{itemize}

$G_i = (V_i, E_i)$ - grafo dirigido pesado, composto por:
\begin{itemize}
	\item $V$ - vértices, representando pontos da rede viária, com:
		\begin{itemize}
			\item $ID$ - Identificador único do vértice
			\item $D$ - Densidade populacional no vértice
			\item $Adj \subseteq E$ - arestas que saiem do vértice
		\end{itemize}
	\item $E$ - arestas, representando conexão entre dois pontos da rede viária, com:
		\begin{itemize}
			\item $ID$ - Identificador único da aresta
			\item $W_d$ - peso da aresta em relação à distância (representa a distância entre os dois vértices)
			\item $W_t$ - peso da aresta em relação ao tempo (representa o tempo médio que demora a percorrer a distância entre os dois vértices, considerando o tráfego normal naquela conexão da rede viária)
			\item $open$ - se a conexão entre os vértices está aberta, isto é, se a rua estiver cortada por alguma razão então não é possível utilizar esta conexão
		\end{itemize}
\end{itemize}

$S$ - vértice da central

\section{Dados de Saída}

$G_f = (V_f, E_f)$ - grafo dirigido pesado, tendo $V_f$ e $E_f$ os mesmos atributos que $V_i$ e $E_i$, excluindo atributos específicos do algoritmo utilizado

$C_f$ - sequência de veículos com os serviços a realizar, sendo $C_f(i)$ o seu i-ésimo elemento. Cada veículo é caraterizado por:
\begin{itemize}
	\item $S$ - sequência de serviços a realizar, sendo $S(i)$ o seu i-ésimo elemento. Cada serviço é caraterizado por:
	\begin{itemize}
		\item $emptySeats$ - número de lugares vazios
		\item $R_f$ - sequência de pedidos atendidos, sendo $R_f(i)$ o seu i-ésimo elemento. Cada pedido atendido é caraterizado por:
		\begin{itemize}
			\item $pickupHour$ - hora de chegada ao local de recolha
			\item $destHour$ - hora de chegada ao local de destino
			\item $p_d$ - peso da distância no trajeto a efetuar
			\item $p_t$ - peso do tempo no trajeto a efetuar
		\end{itemize}
		\item $P = { e ~ \epsilon ~ E_i }$ - sequência de arestas a percorrer, sendo $P(i)$ o seu i-ésimo elemento
		\item $dist$ - distância percorrida no serviço
		\item $startHour$ - hora esperada de ínicio do serviço
		\item $endHour$ - hora esperada de termino do serviço
	\end{itemize}
\end{itemize}

\section{Restrições}

\subsection{Sobre os dados de entrada}

\begin{itemize}
	\item $\forall i ~ \epsilon ~ [0, \vert C_i \vert [: capacity(C_i(i)) > 0$, uma vez que não faz sentido os veículos não poderem transportar prisioneiros
	\item $\forall r ~ \epsilon ~ R_i, dest(r)$ deve pertencer ao mesmo componente fortemente conexo do grafo $G_i$ que o vértice $S$, uma vez que o veículo tem de ser capaz de voltar à central
	\item $\forall r ~ \epsilon ~ R_i, numPris(r) > 0$, uma vez que não faz sentido ter um pedido para transportar zero prisioneiros
	\item $\forall r ~ \epsilon ~ R_i, p_d \geq 0 \wedge p_t \geq 0 \wedge (p_d \neq 0 \vee p_t \neq 0)$
	\item $\forall e ~ \epsilon ~ E_i, W_d(e) > 0 \wedge W_t(e) > 0$, uma vez que o peso da aresta representa a distância ou o tempo médio necessário para percorrer a aresta, se esta distância ou tempo forem zero estaremos num ciclo no mesmo vértice
	\item $\forall e ~ \epsilon ~ E_i, e$ deve ser uma rua ao qual os veículos possam utilizar, ruas que os veículos não tenham permissão para entrar não são incluídas no grafo $G_i$
	\item $S ~ \epsilon ~ V_i$, uma vez que a central é um vértice do grafo $G_i$
\end{itemize}

\subsection{Sobre os dados de saída}

\begin{itemize}
	\item $\vert C_f \vert \leq \vert C_i \vert $ - não se pode usar mais veículos que os disponíveis
	\item $\forall v_f ~ \epsilon ~ V_f, \exists v_i ~ \epsilon ~ V_i$ tal que $v_i$ e $v_f$ têm os mesmos valores para todos os atributos, com exceção de atributos especificos aos algoritmos utilizados
	\item $\forall e_f ~ \epsilon ~ E_f, \exists e_i ~ \epsilon ~ E_i$ tal que $e_i$ e $e_f$ têm os mesmo valores para todos os atributos, com exceção de atributos especificos aos algoritmos utilizados
	\item $\forall r_f ~ \epsilon ~ R_f, \exists r_i ~ \epsilon ~ R_i$ tal que $r_f$ e $r_i$ têm os mesmo valores para os atributos $p_d$ e $p_t$
	\item $\forall c ~ \epsilon ~ C_f, \forall s ~ \epsilon ~ S(c), 0 \leq emptySeats < capacity(c)$ pois cada serviço deve ter pelo menos um prisioneiro, e não pode haver sobrelotação do veículo
	\item $\forall c ~ \epsilon ~ C_f, \forall s ~ \epsilon ~ S(c), \vert R_f(s) \vert > 0$ uma vez que só faz sentido realizar um serviço se for houver um pedido de transporte de prisioneiros
	\item $\forall c ~ \epsilon ~ C_f, \forall s ~ \epsilon ~ S(c), endHour(s) > startHour(s)$
	\item $\forall c ~ \epsilon ~ C_f, \forall s ~ \epsilon ~ S(c), startHour(s) < pickupHour(\forall r ~ \epsilon ~ R_f) < endHour(s) ~ \wedge ~ startHour(s) < destHour(\forall r ~ \epsilon ~ R_f) \leq endHour(s)$
\end{itemize}

\section{Função objetivo}

A solução ótima passa por minizar a soma ponderada da distância percorrida e o tempo do serviço de uma determinada carrinha, que resulta na seguinte função:

$\sum_{c ~ \epsilon ~ C_f} \sum_{s ~ \epsilon ~ S} \sum_{e ~ \epsilon ~ P} (W_d(e) * max(p_d(R_f(s))) + W_t(e) * max(p_t(R_f(s))$

\begin{itemize}
	\item $max(p_d(R_f(s))$ - é o maior valor para o peso da distância numa determinada sequência de pedidos de um serviço de uma carrinha 
	\item $max(p_t(R_f(s))$ - é o maior valor para o peso do tempo numa determinada sequência de pedidos de um serviço de uma carrinha
\end{itemize}

Deste modo, obtivemos a função objetivo para o nosso problema que se encontra acima.

\newpage
%----------------------------------------------------------------------------------------
%	CHAPTER 3 - Perspectiva de solução
%----------------------------------------------------------------------------------------
\chapter[Perspectiva de solução][Perspectiva de solução]{Perspectiva de solução} \label{\thechapter}

\section{Pré-processamento dos dados de entrada}

\subsection{Grafo}
Partindo da central todos as arestas que não forem alcançáveis têm a variável $open$ definida como falsa. 
Além disso, todas os vértices do grafo que não pertencerem à componente fortemente conexa de origem devem ter as arestas que lhe alcançam marcadas como inacessíveis.

\subsection{Pedidos de transporte de prisioneiros}
Remover todos os pedidos de transporte de prisioneiros que não pertençam ao grafo pré-processado, isto é, remover aqueles que façam parte de arestas que têm a componente $open$ definida como falsa.

Também devemos organizar os pedidos de transporte de prisioneiros por ordem decrescente do número de prisioneiros a transportar, facilitando depois no alocamento de veículos para o seu transporte.

\subsection{Veículos para transporte de prisioneiros}
Relativamente ao pré-processamento dos veículos de transporte, devemos organizá-los por ordem decrescente de capacidade. Assim, como também temos os pedidos de transporte de prisioneiros organizados por ordem decrescente do número de prisioneiros a transportar podemos potencialmente minizar o número de veículos utilizados.

\section{Identificação do problema}

A empresa de transporte de prisioneiros Meat Wagons necessita de transportar os prisioneiros  de um ponto de recolha até um determinado destino. De modo a otimizar este transporte, a empresa optou por procurar o caminho mais eficiente para a efetuar a viagem. 

Na primeira iteração, onde apenas está disponível um veículo, que realiza os pedidos de transporte um de cada vez, este problema trata-se do \textbf{caminho mais curto} entre a origem e o local de recolha seguido do \textbf{caminho mais curto} entre o local de recolha e o destino. A segunda iteração é semelhante à primeira iteração, variando apenas o número de veículos disponíveis para realizar os pedidos.

Na terceira e última iteração, não só varia o número de veículos disponíveis, como também o número de pedidos de transporte que um veículo pode realizar num único serviço, equiparando-se ao problema designado por \textbf{Vehicle Routing Problem}, uma generalização do problema do \textbf{Travelling Salesman Problem}, um problema NP-díficil.

Vale também realçar que os veículos devem retornar para a central no fim 

\section{Caminho mais curto}
Este é o problema referido na primeira e segunda iteração, e trata-se de encontrar o percurso mais curto e eficiente entre dois pontos, ou entre todos os pares de pontos do grafo.

\subsection{Entre dois pontos}
Entre os vários algoritmos que existem para calcular o caminho mais curto entre dois pontos destacam-se os seguintes algoritmos:

\subsubsection{Algoritmo de Dijkstra}
Este algoritmo foi concebido por \href{https://en.wikipedia.org/wiki/Edsger_W._Dijkstra}{Edsger W. Dijkstra} e resolve problemas do caminho mais curto de uma única origem em grafos que possuam pesos não negativos.

Para poder aplicar este algoritmo é necessário que cada vértice guarde a seguinte informação:
\begin{itemize}
	\item $W$ - custo mínimo até ao local da origem (combinação linear da distância e tempo, como visto na função objetivo)
	\item $path$ - vértice antecessor no caminho mais curto
\end{itemize}

O algoritmo de Dijkstra pode utilizar uma $priority queue$ ou um $array$ para inserir os novos vértices. No caso da $priority queue$ possui complexidade de $O(|V|+|E|\log |V|)$ enquanto que no caso do array é $O(V^{2})$

\subsubsection{Algoritmo A*}

\subsubsection{Algoritmo de Bellman-Ford}

\subsection{Entre todos os pares de pontos}

\subsubsection{Algoritmo de Floyd-Warshall}

\subsubsection{Johnson's??}

\section{TSP/VRP}

\subsection{Brute-force}

\subsection{Held-Karp}

\subsection{nearest neighbour}

\subsection{genetic}

\newpage
\chapter{Bibliografia}
\begin{itemize}
	\item Apresentações fornecidas pelo professor Rosaldo José Fernandes Rossetti nas aulas téoricas da cadeira \href{https://sigarra.up.pt/feup/pt/ucurr_geral.ficha_uc_view?pv_ocorrencia_id=436441}{Conceção e Análise de Algoritmos}
	\item \href{https://en.wikipedia.org/wiki/Shortest_path_problem}{Shortest Path Problem}
	\item \href{https://en.wikipedia.org/wiki/Dijkstra\%27s_algorithm}{Dijkstra's Algorithm}
	\item \href{https://en.wikipedia.org/wiki/Travelling_salesman_problem}{Traveling Salesman Problem}
	\item \href{https://en.wikipedia.org/wiki/Vehicle_routing_problem}{Vehicle Routing Problem}
\end{itemize}

\end{document}
